---
layout : default
title : The Reactive Principles 번역
parent : Study
grand_parent : OpenSource
---


[The Reactive Principles](https://www.reactiveprinciples.org/edge-native/index.html)

# The Reactive Principles
클라우드 네이티브, 에지 네이티브 또는 사물 인터넷(IoT) 애플리케이션을 구축한다는 것은 신뢰할 수 없는 하드웨어와 신뢰할 수 없는 네트워크에서 분산 시스템을 구축하고 실행하는 것을 의미합니다. 애플리케이션이 설계 및 아키텍처, 그리고 종종 프로그래밍 모델에 아래에 설명된 원칙을 수용하는 경우 애플리케이션은 Reactive로 간주될 수 있습니다.

애플리케이션은 이러한 원칙을 적용하기 위해 Reactive 접근 방식을 사용할 필요가 없지만 확실히 도움이 될 수 있습니다. Reactive가 사용되는 이유가 있습니다!

대부분의 분산 시스템은 일반적으로 클라우드 네이티브 및 에지 네이티브 소개에 설명된 문제 중 일부 또는 전체를 해결하게 되지만 그것만으로는 반응형이 되지 않습니다. "Reactive application"과 Reactive가 아닌 것을 구별하기 위해 어떤 기준을 사용합니까? Reactive는 추상화, 프로그래밍 모델, 프로토콜, 상호 작용 방식, 오류 처리 및 기타 설계 및 아키텍처 영역에서 이러한 문제를 직접 해결합니다. 불행히도 많은 분산 시스템은 이러한 문제를 나중에 생각하는 것으로 간주합니다. 즉, 점점 더 복잡해지는 기술 스택, 래퍼, 해결 방법 및 불행한 누출 추상화를 통해 처리되는 운영 문제 또는 인프라 문제로 간주됩니다.

이 섹션의 나머지 부분은 애플리케이션을 반응성으로 만드는 분산 시스템 구현의 기본 원칙을 안내합니다.

- I. Stay Responsive
- II. Accept Uncertainty
- III. Embrace Failure
- IV. Assert Autonomy
- V. Tailor Consistency
- VI. Decouple Time
- VII. Decouple Space
- VIII. Handle Dynamics

# I. Stay Responsive
항상 적시에 응답하십시오.

응답성이 중요합니다. 많이. 이는 비즈니스의 얼굴이자 서비스 품질, 체인의 마지막 링크, 사용자와의 다리, 사용성과 유용성의 초석입니다.

모든 것이 계획대로 진행될 때 "blue sky" 시나리오에서 응답을 유지하기 쉽습니다. 예상치 못한 장애, 통신 중단 및 예측할 수 없는 작업 부하에 직면했을 때 응답을 유지하는 것도 마찬가지로 중요하지만 훨씬 더 어렵습니다. 궁극적으로 사용자에게 시스템이 시간 제약 내에서 기능을 제공할 수 없다면 시스템이 올바른지 여부는 중요하지 않습니다.

응답성은 짧은 대기 시간과 빠른 응답 시간뿐만 아니라 데이터, 사용 패턴, 컨텍스트 및 환경의 변경 사항을 관리하는 것입니다. 이러한 변경 사항은 애플리케이션과 데이터 모델 내에서 최종 사용자 상호 작용까지 표현되어야 합니다. 변경에 대한 반응은 사람이든 프로그램이든 구성 요소의 사용자에게 전달되어 요청에 대한 응답이 올바른 컨텍스트에서 해석될 수 있습니다.

반응형 애플리케이션은 문제를 효과적으로 감지하고 처리합니다. 반응형 애플리케이션은 빠르고 일관된 응답 시간을 제공하는 데 중점을 둡니다. 최악의 경우 오류 메시지로 응답하거나 저하되었지만 여전히 유용한 서비스 수준을 제공합니다. 이는 응답 대기 시간에 대해 상호 이해되는 상한선을 설정하여 일관된 서비스 품질을 제공하기 위한 기반을 만듭니다. 이러한 일관된 동작은 차례로 오류 처리를 단순화하고 최종 사용자의 신뢰를 구축하며 추가 상호 작용을 장려합니다.

응답성은 시스템의 많은 측면에 영향을 받기 때문에 파악하기 어려울 수 있습니다. 경합, 조정, 결합, 데이터 흐름, 통신 패턴, 리소스 관리, 장애 처리 및 불확실성에 이르기까지 모든 것에 영향을 받습니다. 이것은 다른 모든 원칙과 연결되고 동기를 부여하는 기본 개념입니다.

# II. Accept Uncertainty
신뢰할 수 없는 기반에도 불구하고 안정성 구축

우리가 로컬 머신이나 컨테이너의 경계를 넘어서자 마자 우리는 광대하고 끝없는 비결정론의 바다, 즉 분산 시스템의 세계로 들어갑니다. 시스템이 가장 화려하고 복잡한 방식으로 실패할 수 있고 정보가 손실되고 재정렬되고 손상되고 실패 감지가 추측 게임인 무서운 세계입니다. 불확실한 세상입니다.

가장 중요한 것은 "지금"이 없다는 것입니다. 현재는 관찰자의 관점에 따라 상대적이고 주관적입니다. 일관되고 안정적인 공유 메모리의 부족으로 인한 이 세상의 근본적인 문제는 현재 다른 노드에서 무슨 일이 일어나고 있는지 알 수 없다는 것입니다. 우리는 결정에 필요한 정보를 무기한 기다릴 수 없음을 인정해야 합니다. 결과적으로, 우리의 알고리즘은 하드웨어 결함, 신뢰할 수 없는 네트워크 또는 통신 지연이라는 단순한 물리적 문제로 인해 정보가 부족할 것입니다. 데이터는 인정될 때쯤이면 오래된 것이고 우리는 파편화되고 불균등하게 오래된 상태를 처리해야 합니다.

이러한 불확실성을 조절하고 세계에 대한 강력한 일관된 관점을 생성하기 위해 잘 정립된 분산 알고리즘이 있음에도 불구하고 이러한 알고리즘은 성능 및 확장성 특성이 좋지 않은 경향이 있으며 네트워크 파티션 중에 사용할 수 없음을 의미합니다. 결과적으로, 분산 시스템의 경우 응답성을 달성하기 위해 필요한 절충안으로 대부분을 포기해야 했으며, 인과적, 최종적 및 기타와 같이 훨씬 낮은 수준의 일관성에 동의하고 더 높은 수준을 수용하게 되었습니다. 그들과 함께 오는 불확실성의 수준.

여기에는 많은 의미가 있습니다. 시계와 타임스탬프 또는 순서(인과 관계 새 탭이 존재하지 않을 수도 있음)로 측정되는 시간을 항상 신뢰할 수는 없습니다. 이러한 불확실성을 받아들이고 이에 대처하기 위한 전략을 사용해야 합니다. 예: 논리적 시계 새 탭에 의존(예: 벡터 시계 새 탭); 적절한 경우 최종 일관성 새 탭을 사용합니다(예: 특정 NoSQL 새 탭 데이터베이스 및 CRDT 새 탭). 그리고 우리의 통신 프로토콜이 연관 새 탭(일괄 구분 없음), 교환 새 탭(순서 구분 안함) 및 멱등원 새 탭(중복 구분 없음)인지 확인합니다.

핵심은 애플리케이션 아키텍처에서 직접 불확실성을 관리하는 것입니다. 자신의 프로토콜을 세상에 공개하는 탄력적인 자율 구성 요소를 설계하기 위해 약속할 수 있는 것, 수락할 명령 및 이벤트, 결과적으로 트리거할 동작 및 데이터 모델 사용 방법을 명확하게 정의하는 프로토콜 . 기본 정보의 적시성과 평가된 정확성은 적절한 경우 다른 구성 요소에서 볼 수 있어야 하므로 해당 구성 요소가 현재 시스템 상태의 신뢰성을 판단할 수 있습니다.

# III.Embrace Failure
일이 잘못될 것을 예상하고 탄력성을 위해 설계

Reactive Manifesto의 정의에 따르면 실패는 구성 요소가 요청을 처리하지 못하게 하는 조건을 나타내는 반면 오류는 프로그램에서 발생하는 정상적인 조건을 나타냅니다. 입력 유효성 검사 — 로 인해 호출 구성 요소에 직접 다시 신호를 보냅니다.

반응형 응용 프로그램은 실패를 결국 발생할 예상 조건으로 간주합니다. 따라서 장애는 인프라, 감독자 구성 요소 또는 구성 요소 자체 내(내부 중복성 사용)와 같은 특정 수준에서 명시적으로 표시되고 처리되어야 합니다. 구성 요소 자율성이 이미 응용 프로그램 기능의 가능한 한 작은 영역에 오류가 포함되도록 보장하더라도 오류가 발생한 경우에도 가능한 한 요청에 응답해야 합니다. 공간 분리를 통해 지정된 오류 영역 내에 오류를 보관할 수 있고, 시간 분리를 통해 다른 구성 요소가 명시적으로 통신할 수 없는 경우에도 오류를 안정적으로 감지하고 처리할 수 있습니다.

명시적으로 표시된 오류 조건을 통해 구성 요소는 자동으로 완전히 실패하는 대신 의도적으로 저하된 서비스를 제공할 수 있습니다. 가능하면 자가 치유 기능을 구현하는 데에도 사용할 수 있지만 구성 요소를 종료하고 다시 시작하는 let it crash 접근 방식을 제외하고는 일반적인 방식으로 수행할 수 없습니다. Actor Model 새 탭의 구현에 성공적으로 사용된 전략입니다. 예를 들어 Erlang 새 탭, Akka 새 탭, Elixir 새 탭 및 VLINGO 새 탭.

실패를 감지할 수 없을 수도 있다는 점을 언급하는 것도 중요합니다. 따라서 애플리케이션이 정확성을 확신하는 것이 항상 가능한 것은 아닙니다. 그러나 감지할 수 없는 오류가 계속해서 정상적으로 작동해야 하는 응용 프로그램에 영향을 주어서는 안 됩니다.

이러한 기능은 강력한 기능이지만 비반응성 컨텍스트(예: 단일 구성 요소의 비분산 구현 내)에서 사용하는 것은 일반적으로 예외와 같은 기존 메커니즘을 사용하는 것보다 더 많은 작업이 필요합니다. 실패를 처리하는 가장 좋은 방법은 프로그래밍 언어와 패러다임의 특정 선택에 달려 있습니다. 여기서 실패와 오류 모두에 대해 예외를 사용하는 경우 예를 들어 다음과 같이 합계 유형의 새 탭을 사용하는 것보다 명시적 표현에서 더 많은 이익을 얻습니다. 오류가 있는 결과를 반환하고 실패 시 프로그램을 중단합니다.

명시적으로 표시된 실패의 또 다른 용도는 다른 스레드, 프로세스 또는 네트워크를 통해 값으로 전달될 수 있다는 것입니다. 이것은 다양한 리액티브 프로그래밍 기술에서 플랫폼 및 언어별 방식으로 사용됩니다. 예를 들어:

- Reactive Streams의 onError 신호. 새로운 탭

- async/await를 사용하여 Observable 새 탭 스트림에서 예외를 던지고 잡는 형태.

- Actor Model에서와 같이 완전한 캡슐화를 보장하기 위해 오류의 특성이 아닌 발생만 통신합니다. 새로운 탭

# IV. Assert Autonomy
독립적으로 작동하고 협력적으로 상호 작용하는 구성 요소 설계

더 큰 시스템의 구성 요소는 시스템의 나머지 부분에 대한 자율성 정도에 따라 응답할 수 있습니다. Reactive 애플리케이션에서 자율성은 구성 요소 경계를 명확하게 정의하고, 누가 어떤 데이터를 소유하고 소유자가 이를 사용할 수 있도록 하며, 각 당사자가 스스로 결정을 내리는 데 필요한 정도의 자유를 갖도록 설계함으로써 달성됩니다.
서비스가 다른 구성 요소를 호출할 때 해당 구성 요소는 예를 들어 과부하 또는 잘못된 종속성으로 인한 일시적인 성능 저하를 다시 전달할 수 있어야 합니다. 그리고 적절할 때, 특히 무거운 짐을 흘릴 때 응답하지 않을 자유가 있어야 합니다. 이를 위해서는 사용된 API가 동기적으로 보이는 경우에도 이러한 구성 요소 간의 프로토콜이 비동기적이고 이벤트 기반이어야 합니다.  결국 프로토콜이 실패하거나 늦은 응답의 가능성을 예측할 때만 구성 요소 수준 오류를 포함할 수 있습니다.

자율성의 또 다른 측면은 두 구성 요소 사이의 경계가 문서화된 프로토콜을 통해서만 넘어간다는 것입니다. 다른 부채널이 있을 수 없습니다. 이 원칙을 통해서만 협업에 대해 추론하고 잠재적으로 공식적으로 검증할 수 있습니다(예: 세션 유형 새 탭 사용). 많은 경우 프로토콜은 요청-응답 새 탭 메시지 쌍과 같이 사소하지만 다른 경우에는 백프레셔(Reactive Streams 새 탭에서와 같이) 또는 여러 당사자 간의 복잡한 합의 프로토콜이 포함될 수 있습니다. 중요한 부분은 통신 설계 내에서 참가자의 자율성을 존중하면서 프로토콜이 완전히 지정된다는 것입니다.

자율성을 촉진하는 가치 있는 패턴에는 도메인 주도 디자인 새 탭, 이벤트 소싱 새 탭 및 CQRS 새 탭이 있습니다. 완전히 독립적인 사실을 전달하면  기본 비즈니스 도메인을 밀접하게 모델링하여  받는 사람이 추가 정보를 다시 요청할 필요 없이 스스로 결정을 내릴 수 있습니다. CQRS는 한 위치(한 구성 요소)에서 시스템의 한 부분에 대한 결정을 내림으로써 우려 사항을 분리합니다. 그러면 나중에 쉽게 전파되고 다른 곳에서 조치를 취할 수 있습니다.

# V. Tailor Consistency
가용성과 성능의 균형을 맞추기 위해 구성 요소별로 일관성을 개별화

일관성은 애플리케이션과 사용자 데이터의 정확성과 무결성을 보장하는 것입니다. 실제로 필요한 것보다 더 많은 일관성 보장을 제공하면 가치가 추가되지 않으며 애플리케이션의 가용성, 효율성 및 성능이 저하될 뿐입니다. 고객에게 안정적으로 서비스를 제공할 수 없다면 당신이 옳다고 해도 문제가 되지 않습니다.

## 강한 일관성
강력한 일관성 새 탭(엄격한 직렬화 가능성을 의미함) -  비공식적으로 외부 관찰자가 행동을 마치 단일 로컬 시스템과 상호 작용하는 것처럼 본다는 의미) 직관적이고 추론하기 쉽지만 동기식 통신 및 조정이 필요하며 궁극적으로 모든 관련 참가자의 가용성. 이는 장애 조건에서 진행을 중지하고 시스템을 응답하지 않게 만들고 정상적인 환경에서 진행 속도를 늦출 수 있는 요구 사항입니다.

분산 시스템의 수렴에 대해 생각하는 데 도움이 되는 방법은 시스템이 항상 수렴 과정에 있지만 (전 세계 시스템 규모에서) 수렴의 최종 상태를 완전히 "따라잡아" 도달하지 못한다는 것입니다. 그렇기 때문에 일정 수준의 예측 가능성과 확실성을 줄 수 있는 "일관성 단위"(끊임없는 변화와 불확실성의 강에서 강한 일관성의 작은 섬)를 신중하게 정의하는 것이 중요합니다.

가능한 경우 참가자의 지연 및 일시적인 비가용성을 허용하는 비동기 처리를 활용하여 결과적 일관성 새 탭 또는 인과적 일관성 새 탭을 위한 시스템 설계(예: 이벤트 기반 아키텍처 새 탭, 특정 NoSQL 새 탭 데이터베이스 및 CRDT 새 탭 사용) ). 이를 통해 시스템은 가용성을 유지하고 결국 수렴되며, 장애가 발생할 경우 자동으로 복구됩니다.

사용 사례의 정확성을 위해 강력한 일관성이 본질적으로 필요한 경우 일관성 경계가 명확하게 정의되어 신중하고 선택적으로 적용되어야 하며 일관성 단위를 최대한 작게 유지하여 최대의 확장성과 가용성을 유지해야 합니다.

# VI. Decouple Time
조정 및 대기를 피하기 위해 비동기식으로 처리

"침묵은 금이다"라고 말하며 현실 세계와 마찬가지로 소프트웨어 시스템에서도 마찬가지입니다. Amdahl의 법칙 새 탭과 Universal Scalability Law 새 탭은 불필요한 의사 소통, 조정 및 대기를 피함으로써 확장성의 한계를 높일 수 있음을 보여줍니다.

우리는 여전히 의사소통을 하고 행동을 조정해야 할 때가 있습니다. 리소스 차단 문제(예: I/O 새 탭은 물론 다른 서비스를 호출할 때도 있음)는 실행 중인 스레드를 포함하여 호출자가 리소스를 사용할 수 있게 되기를 기다리는 인질로 잡혀 있다는 것입니다. 이 시간 동안 호출 구성 요소(또는 그 일부)는 다른 요청에 사용할 수 없습니다.

이것은 시간적 분리를 사용하여 완화하거나 피할 수 있습니다. 시간적 분리는 원격 구성 요소 간의 시간 가용성 종속성을 깨는 데 도움이 됩니다. 여러 구성 요소가 동기적으로 메시지를 교환할 때 교환 기간 동안 이러한 모든 구성 요소의 가용성과 도달 가능성을 가정합니다. 이것은 시스템의 모든 구성 요소에 대한 가용성이나 도달 가능성을 항상 보장할 수 없는 분산 시스템의 맥락에서 취약한 가정입니다. 우리의 통신 프로토콜에 시간적 분리를 도입함으로써 한 구성 요소는 다른 구성 요소의 가용성을 가정하고 요구할 필요가 없습니다. 구성 요소를 보다 독립적이고 자율적으로 만들고 결과적으로 전체 시스템을 보다 안정적으로 만듭니다. 임시 디커플링을 구현하는 인기 있는 기술에는 영구 메시지 대기열, 추가 전용 저널 및 보존 기간이 있는 발행-구독 주제가 있습니다.

시간적 분리를 통해 호출자에게 리소스를 사용할 수 있을 때까지 기다리지 않고 비동기적으로 새 탭에서 다른 작업을 수행할 수 있는 옵션을 제공합니다. 이것은 호출자가 자신의 요청을 대기열에 넣고, 나중에 알림을 받을 콜백 새 탭을 등록하고, 즉시 반환하고, 실행을 계속하도록 허용함으로써 달성할 수 있습니다(예: 비차단 I/O 새 탭). 콜백을 오케스트레이션하는 좋은 방법은 FSM(Finite State Machine 새 탭)을 사용하는 것입니다. 기타 기술에는 Futures/Promises 새 탭, Dataflow Variables, 새 탭 Async/Await 새 탭, Coroutine 새 탭 및 비동기 기능 결합기의 구성이 포함됩니다. 스트리밍 라이브러리의 탭입니다.

앞서 언급한 프로그래밍 기술은 Reactive 응용 프로그램의 각 구성 요소에 자체 우선 순위에 따라 들어오는 정보를 처리하도록 선택할 수 있는 더 많은 자유를 제공하는 상위 수준 목적을 제공합니다. 따라서 이러한 분리는 구성 요소에 더 많은 자율성을 부여합니다.

# VII. Decouple Space
네트워크를 수용하여 유연성 확보

기본 하드웨어의 일부가 오작동하거나 액세스할 수 없을 때 작동할 수 있도록 여러 위치에 배치할 수 있는 경우에만 탄력적인 시스템을 만들 수 있습니다. 즉, 공간 전체에 부품을 분산해야 합니다. 일단 배포되면 이제 자율적인 구성 요소는 주어진 사용 사례에 대해 가능한 한 느슨하게 결합되어 하나의 특정 위치에서 새로 얻은 독립성을 최대한 활용하기 위해 협력합니다.

이 공간적 분리는 네트워크 통신을 사용하여 잠재적으로 원격 부분을 다시 연결합니다. 모든 네트워크는 노드 간에 메시지를 전달하여 작동하고 이 메시지 전달에는 시간이 걸리므로 공간 분리는 기본 수준에서 비동기 메시지 전달 새 탭을 도입합니다. 이 측면의 상위 수준 표현은 gRPC 새 탭, NATS.io 새 탭, Apache Kafka 새 탭, HTTP 및 REST입니다. 결정하는.

비동기식 메시징 및/또는 API의 주요 측면은 모든 제약 조건이 있는 네트워크를 설계에서 명시적이고 일류로 만든다는 것입니다. 네트워크가 없는 척하고 누출된 로컬 추상화 새 탭(예: 네트워크 연결 디스크) 뒤에 숨기려고 하는 대신 실패와 불확실성에 대한 설계를 강요합니다. , 메시지 손실 또는 재정렬.

또한 구성 요소가 동일한 물리적 시스템, 다른 랙 또는 다른 데이터 센터에 같은 위치에 있는지 여부에 관계없이 모든 구성 요소 상호 작용에 대해 하나의 단일 추상화를 제공하는 위치 투명성 새 탭을 허용합니다. 비동기식 API를 사용하면 검색 서비스 및 로드 밸런서와 같은 클라우드 인프라가 컨테이너 또는 VM이 ​​실행되는 모든 곳으로 요청을 라우팅하는 동시에 끊임없이 변화하는 대기 시간 및 장애 특성의 가능성을 수용할 수 있습니다. 이것은 시스템이 배포된 방법이나 시스템이 현재 가지고 있는 토폴로지(사용에 따라 변경될 수 있음)에 관계없이 하나의 프로그래밍 모델에 단일 의미 집합을 제공합니다.

공간 분리는 복제를 가능하게 하여 궁극적으로 시스템의 복원력과 가용성을 높입니다. 구성 요소의 여러 인스턴스를 실행하면 이러한 인스턴스가 로드를 공유할 수 있습니다. 위치 투명성 덕분에 시스템의 나머지 부분은 이러한 인스턴스의 위치를 ​​알 필요가 없지만 요청 시 시스템 용량을 투명하게 늘릴 수 있습니다. 한 인스턴스가 충돌하거나 배포 취소되면 다른 복제본이 계속 작동하고 로드를 공유합니다. 이러한 장애 조치 기능은 서비스 중단을 방지하는 데 필수적입니다.

# VIII. Handle Dynamics
조정 및 대기를 피하기 위해 비동기식으로 처리

"침묵은 금이다"라고 말하며 현실 세계와 마찬가지로 소프트웨어 시스템에서도 마찬가지입니다. Amdahl의 법칙 새 탭과 Universal Scalability Law 새 탭은 불필요한 의사 소통, 조정 및 대기를 피함으로써 확장성의 한계를 높일 수 있음을 보여줍니다.

우리는 여전히 의사소통을 하고 행동을 조정해야 할 때가 있습니다. 리소스 차단 문제(예: I/O 새 탭은 물론 다른 서비스를 호출할 때도 있음)는 실행 중인 스레드를 포함하여 호출자가 리소스를 사용할 수 있게 되기를 기다리는 인질로 잡혀 있다는 것입니다. 이 시간 동안 호출 구성 요소(또는 그 일부)는 다른 요청에 사용할 수 없습니다.

이것은 시간적 분리를 사용하여 완화하거나 피할 수 있습니다. 시간적 분리는 원격 구성 요소 간의 시간 가용성 종속성을 깨는 데 도움이 됩니다. 여러 구성 요소가 동기적으로 메시지를 교환할 때 교환 기간 동안 이러한 모든 구성 요소의 가용성과 도달 가능성을 가정합니다. 이것은 시스템의 모든 구성 요소에 대한 가용성이나 도달 가능성을 항상 보장할 수 없는 분산 시스템의 맥락에서 취약한 가정입니다. 우리의 통신 프로토콜에 시간적 분리를 도입함으로써 한 구성 요소는 다른 구성 요소의 가용성을 가정하고 요구할 필요가 없습니다. 구성 요소를 보다 독립적이고 자율적으로 만들고 결과적으로 전체 시스템을 보다 안정적으로 만듭니다. 임시 디커플링을 구현하는 인기 있는 기술에는 영구 메시지 대기열, 추가 전용 저널 및 보존 기간이 있는 발행-구독 주제가 있습니다.

시간적 분리를 통해 호출자에게 리소스를 사용할 수 있을 때까지 기다리지 않고 비동기적으로 새 탭에서 다른 작업을 수행할 수 있는 옵션을 제공합니다. 이것은 호출자가 자신의 요청을 대기열에 넣고, 나중에 알림을 받을 콜백 새 탭을 등록하고, 즉시 반환하고, 실행을 계속하도록 허용함으로써 달성할 수 있습니다(예: 비차단 I/O 새 탭). 콜백을 오케스트레이션하는 좋은 방법은 FSM(Finite State Machine 새 탭)을 사용하는 것입니다. 기타 기술에는 Futures/Promises 새 탭, Dataflow Variables, 새 탭 Async/Await 새 탭, Coroutine 새 탭 및 비동기 기능 결합기의 구성이 포함됩니다. 스트리밍 라이브러리의 탭입니다.

앞서 언급한 프로그래밍 기술은 Reactive 응용 프로그램의 각 구성 요소에 자체 우선 순위에 따라 들어오는 정보를 처리하도록 선택할 수 있는 더 많은 자유를 제공하는 상위 수준 목적을 제공합니다. 따라서 이러한 분리는 구성 요소에 더 많은 자율성을 부여합니다.

