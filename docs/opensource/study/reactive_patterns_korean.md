---
layout : default
title : Reactive Patterns 번역
parent : Study
grand_parent : OpenSource
---


[Reactive Patterns](https://www.reactiveprinciples.org/patterns/index.html)

다음 패턴은 애플리케이션 및 시스템에서 Reactive Principles를 체계화하고 적용하는 데 도움이 될 수 있습니다. 이러한 패턴이 모든 문제, 사용 사례 및 컨텍스트에 적용되는 것은 아니지만 필요할 때 선택적으로 사용하고 적용할 수 있는 도구 상자의 도구로 보아야 합니다.

고정된 패턴 세트가 아니라 커뮤니티에서 유지 관리하는 성장하고 생활 패턴 카탈로그의 시작점을 의미합니다. 새로운 패턴에 대한 아이디어가 있거나 기존 패턴을 개선하는 데 도움을 주고 싶다면(패턴 토론에 대해 자세히 설명하거나, 예제를 추가하거나, 샘플 코드까지) 이 문서에 기여하는 방법을 읽으십시오. 우리는 당신의 도움이 필요합니다.

- Partition State
- Communicate Facts
- Isolate Mutations
- Coordinate Dataflow
- Localize State
- Observe Communications

# Partition State
시스템의 병렬 처리를 활용하기 위해 상태를 더 작은 청크로 나눕니다.

분산 응용 프로그램은 메모리를 공유하지 않는 컴퓨터 그룹에서 동시에 실행하여 기본 하드웨어의 병렬 처리를 활용합니다. 다중 코어 서버의 이러한 병렬 사용은 다중 시스템 수준에 조정 및 동시성 제어 문제를 가져오고 단일체로서의 상태 처리를 비효율적이고 종종 불가능하게 만듭니다. 상태 분할은 확장성에도 도움이 됩니다. 각 노드는 유한 데이터 세트만 저장하고 처리할 수 있지만 노드의 네트워크는 더 큰 계산 문제를 처리할 수 있습니다.

대부분의 분산 시스템에서 사용되는 잘 정립된 패턴에는 모놀리식 상태를 대부분 서로 독립적으로 관리되는 더 작은 청크, 파티션 세트로 나누는 것이 포함됩니다. 새 탭 이러한 방식으로 더 효율적이고 내결함성이 있는 실행을 위해 사용 가능한 병렬 처리를 활용할 수 있습니다.

계정, 구매 주문, 장치 및 사용자 세션과 같은 일부 데이터 세트는 자연스럽게 분할됩니다. 다른 것들은 데이터를 분할하는 방법과 파티션 키로 사용할 항목에 대해 보다 신중한 고려가 필요합니다.

상태 분할에는 일관성이 다소 희생되는 경우가 많습니다. 데이터 파티션을 대부분 또는 완전히 서로 독립적으로 관리한다는 바로 그 아이디어는 원자성 및 격리와 같은 파티션 경계를 포괄하는 보장을 보장하는 데 필요한 조정 프로토콜에 위배됩니다. 이러한 이유로 상태 파티셔닝은 일반적으로 한편으로는 성능, 확장성 및 내결함성과 다른 한편으로는 일관성 및 단순성 간의 명시적인 절충을 요구합니다.

# Communicate Facts
변경 가능한 상태보다 변경 불가능한 이벤트 스트림 선택

가변 상태는 시간이 지남에 따라 안정적이지 않습니다. 항상 현재/최신 값을 나타내며 이전 값을 덮어쓰는 파괴적인 내부 업데이트를 통해 발전합니다. 문제의 본질은 가변 상태가 가치와 정체성의 개념을 같은 것으로 취급한다는 것입니다. ID는 현재 나타내는 값을 변경하지 않고는 진화할 수 없으므로 뮤텍스 등으로 보호해야 합니다.

변경 가능한 상태에 대한 동시 업데이트는 데이터 손상의 악명 높은 원인입니다. 공유된 상호 상태에 대한 업데이트를 안전하게 처리하기 위한 잘 정립된 기술과 알고리즘이 있지만 두 가지 주요 단점이 있습니다. 이러한 알고리즘의 복잡성은 특히 코드가 발전함에 따라 잘못되기 쉽고 성능과 확장성에 상한선을 두는 특정 수준의 조정이 필요합니다. 변경 가능한 상태에 대한 업데이트의 파괴적인 특성으로 인해 실수로 인해 쉽게 감지하고 복구하는 데 비용이 많이 드는 데이터 손상 및 손실이 발생할 수 있습니다.

대신, 손상되거나 일관성 없는 데이터에 대해 걱정하거나 트랜잭션 또는 잠금으로 보호하지 않고 로컬 또는 분산 이벤트로 안전하게 공유할 수 있는 불변 상태(사실을 나타내는 값)에 의존합니다.

Fact는 불변이며 과거 언젠가 이미 발생한 것, 변경하거나 철회할 수 없는 것을 나타냅니다. 무한정 추론하고 신뢰할 수 있는 안정적인 가치입니다. 결국, 우리는 때때로 우리가 원하더라도 과거를 바꿀 수 없습니다. 지식은 누적되며 새로운 사실을 받거나 기존 사실에서 새로운 사실을 도출함으로써 발생합니다. 기존 지식의 무효화는 기존 사실을 반박하는 시스템에 새로운 사실을 추가하여 수행됩니다. 사실은 절대 삭제되지 않으며 현재 지식과 관련이 없을 뿐입니다.

Fact는 통신, 통합 및 복제를 위한 매개체 역할을 하는 다른 구성 요소(구성 요소, 데이터베이스 또는 하위 시스템)에 의해 구독 및 소비될 수 있는 구성 요소의 이벤트 스트림을 통해 이벤트로 게시함으로써 가장 잘 공유됩니다. _event log 새 탭에 이벤트로 저장된 사실은 인과 순서에 따라 메모리에서 안전하게 읽기를 제공하는 동안(예: Event Sourcing 새 탭 패턴 사용) 구성 요소 상태 변경의 전체 기록을 나타낼 수 있습니다(메모리 이미지 새 탭이라고 함).

# Isolate Mutations
격벽을 사용하여 변경 가능한 상태를 포함 및 격리

가변 상태를 사용해야 하는 경우 공유하지 마십시오. 대신 "격벽" 새 탭으로 구분된 격리되고 분할된 구획을 사용하여 관련 동작과 함께 이를 포함하고 비공유 아키텍처를 채택합니다. 새 탭 여기에는 실패가 포함되어 있고, 실패한 구성 요소 외부로 전파되는 것을 방지하고, 범위를 제한하고, 더 쉽게 찾아내고 관리할 수 있도록 현지화합니다. 또한 "계단식 오류"로 이어지는 사소한 문제와 전체 시스템 중단을 방지합니다. 예를 들어 유효성 검사 오류는 실패가 아니라 상태 저장 구성 요소의 일반적인 상호 작용 프로토콜의 일부라는 것을 기억하십시오.

격벽은 구성 요소 사이에 프로토콜 경계를 도입하여 시간과 공간 모두에서 격리하는 비동기 메시징 새 탭을 사용하여 구획이 통신하도록 함으로써 가장 쉽게 설치됩니다. 또한 비동기식 메시징을 사용하면 변동하는 수요를 관찰하고, 격벽 범람을 방지하고, 필요한 경우 복제 단위를 제공할 수 있습니다.

변이에 대한 안전한 피난처를 제공하는 일관성의 단위인 벌크헤드 구성 요소의 일관성 경계 내에서 로컬 계산에 대해서만 변경 가능한 상태를 사용합니다.
구성 요소가 로컬 처리를 완료하고 결과에 대해 세상에 알릴 준비가 되면 결과(사실)를 나타내는 변경할 수 없는 값을 만들어 세상에 게시합니다.

벌크헤드 구성 요소는 이상적으로 단일 스레드 실행을 사용하여 프로그래밍 모델을 단순화하고 교착 상태, 경쟁 조건 및 손상된 데이터와 같은 동시성 관련 문제를 방지해야 합니다. 예를 들어 Node.js 새 탭, Akka 새 탭, Disruptor 새 탭 또는 Reactor 새 탭 구현 패턴 및 해당 변형이 이 기능을 제공합니다.

이 모델에서 다른 구성 요소는 추론을 위해 안정적이고 변경할 수 없는 값에 의존할 수 있는 반면, 각 구성 요소는 내부적으로 변경 가능성(코딩의 단순성 및 알고리즘 효율성과 같은), 강력한 일관성(ACID 새 탭 의미 체계 제공), 조정 및 경합 감소(Single Writer Principle 새 탭을 통해).

# Coordinate Dataflow
지속적이고 안정적인 정보 흐름 조정

Reactive는 워크플로의 구성 요소 구성을 통해 데이터 기반 응용 프로그램을 만드는 데 빛을 발합니다. 데이터 흐름 측면에서 생각하면 데이터가 시스템을 통해 흐르는 방식, 데이터가 트리거하는 동작 및 위치, 구성 요소가 인과적으로 관련되는 방식 새 탭을 통해 구조에만 국한되지 않고 동작에 집중할 수 있습니다. 구성 요소(또는 하위 시스템)가 서로의 이벤트 스트림을 구독하도록 하여 워크플로 및 통합을 조정하고 비동기적으로 게시된 사실을 주문형으로 소비합니다.

소비자는 사용 사례에 따라 생산 속도와 분리될 수 있는 소비율을 제어해야 합니다. 자신의 소비율을 통제하는 소비자를 압도하는 것은 불가능합니다. 이것이 일부 아키텍처에서 메시지 대기열을 사용하는 이유 중 하나입니다. 메시지 대기열은 추가 로드를 흡수하고 소비자가 여가 시간에 작업을 소모할 수 있도록 합니다. 일부 아키텍처는 메시지 생성을 완전히 취소하는 방법으로 "독약" 메시지를 설계합니다. 소비 속도를 제어하는 ​​소비자와 생산 속도를 중지하는 대역 외 메커니즘의 조합은 흐름 제어를 지원합니다. 흐름 제어는 시스템 아키텍처 수준에서 명백한 승리이지만 낮은 수준에서는 무시하기가 너무 쉽습니다.

흐름 제어는 과도한 부담을 가진 소비자가 실패하거나 제한 없이 리소스를 소비하지 않도록 모든 참가자와 함께 엔드 투 엔드로 관리해야 합니다. 기본적으로 지원하고 표준화된 프로토콜을 사용하여 구성하는 라이브러리는 광범위한 구현(예: Reactor 새 탭, RxJava 새 탭, Vert.x 새 탭, Akka Streams 새 탭, Mutiny)이 있는 Reactive Streams 프로토콜 새 탭과 같이 엄청난 도움이 될 수 있습니다. 새 탭 및 RSocket 새 탭).

Reactive Streams는 소비자가 따라갈 수 없을 때 생산자가 속도를 늦추는 역압 새 탭이라는 체계를 사용합니다. 또 다른 방식은 생산자와 소비자 사이에 메시지 대기열을 배치하고 이 대기열의 활용에 반응하는 것입니다. 예를 들어 소비자에게 더 많은 리소스를 제공하거나 생산자의 기능을 늦추거나 저하시키는 방식입니다.

구성 요소가 서로 또는 타사 시스템과 구성되고 상호 작용하는 가장자리에서 데이터 흐름에 대한 특별한 주의가 필요합니다. 정상적인 성능 저하 및 흐름 제어를 위한 프로토콜을 설정한다는 것은 실패 가능성을 줄이는 것을 의미하며, 불가피하게 실패할 경우 이를 관리할 수 있는 제어 메커니즘을 갖추는 것이 좋습니다.

# Localize State
상태 및 처리를 함께 배치하여 데이터 소유권 확보

데이터 집약적인 응용 프로그램 및 사용 사례에서는 상태와 처리를 함께 배치하여 단일 정보 소스를 제공하면서 참조 새 탭의 큰 지역성을 유지하는 것이 종종 유리합니다. new tab Co-location을 사용하면 대기 시간이 짧고 처리량이 높은 데이터 처리와 작업 부하를 더 고르게 분산할 수 있습니다.

공동 위치를 달성하는 한 가지 방법은 처리를 상태로 이동하는 것입니다. 이는 읽기 및 쓰기 경합을 피하면서 비즈니스 로직이 각 샤드에서 프로세스 내에서 실행되는 메모리 내 데이터의 클러스터 샤딩 새 탭(예: 엔티티 키 샤딩)을 사용하여 효과적으로 달성할 수 있습니다. 이상적으로 인메모리 데이터는 강력한 일관된 방식(예: Event Sourcing 새 탭 및 메모리 이미지와 같은 패턴 사용)으로 기본 저장소에 매핑하여 단일 정보 소스를 나타내야 합니다. 새로운 탭

공동 위치는 가장 자주 사용되는 데이터의 읽기 전용 복사본을 처리 컨텍스트에 가깝게 유지 관리하는 새 탭 캐싱과 다르며 이를 보완합니다. 캐싱은 일부 상황(특히 사용 사례가 읽기가 많은 경우)에서 매우 유용합니다. 그러나 마스터 데이터와 동기화 상태를 유지하는 것과 관련된 복잡성이 추가되어 원하는 수준의 일관성을 유지하기 어려워 캐시된 데이터를 단일 소스로 사용할 수 없습니다.

공동 위치를 얻는 또 다른 방법은 상태를 처리로 이동하는 것입니다. 이는 데이터의 일관된 수렴을 보장하는 기술을 활용하면서 비즈니스 로직이 실행될 수 있는 모든 노드에 데이터 새 탭을 복제하여 달성할 수 있습니다(예: 가십 프로토콜 새 탭과 함께 CRDT 새 탭 사용). 이러한 기술은 추가 스토리지 인프라 없이도 높은 수준의 가용성을 보장하는 추가적인 이점이 있으며 스택의 모든 수준에서 데이터 일관성을 유지하는 데 사용할 수 있습니다. 강력한 일관성이 필요하지 않은 구성 요소, 노드, 데이터 센터 및 클라이언트 전반에 걸쳐

# Observe Communications
시스템의 역학을 살펴봄으로써 시스템을 이해하십시오.

응용 프로그램과 시스템의 복잡성이 증가함에 따라 시스템 자체 검사가 엄격한 요구 사항이 되었습니다. 관찰 가능성은 간단한 질문에 답하기 위해 데이터를 수집하는 것입니다. 시스템이 어떻게 작동합니까? 관찰 가능성을 통해 현재 또는 과거에 진행 중인 상황을 이해하고 시스템의 보다 정확한 상태를 제공하여 추세를 식별하는 데 도움이 됩니다.

일반적으로 관찰 가능성은 애플리케이션 메트릭, 네트워크 메트릭, 상태 보고서, 로그 및 추적을 구성합니다. 이들로부터 시스템의 가용성과 안정성을 강화하는 다른 종합 메트릭 및 경고를 도출합니다.

Reactive 시스템에서는 응용 프로그램뿐만 아니라 통신 조직도 관찰하는 것이 필수적입니다. 애플리케이션 메트릭은 시스템의 전체 상태에 대한 현명한 결정을 내리기에 충분하지 않은 경우가 많습니다. 통신을 살펴봄으로써 시스템 역학(데이터 흐름 방식)을 추출할 수 있습니다. 데이터 소비자, 생산자, 교환 및 대기열 크기에 대한 정보를 수집하면 병목 현상과 오작동 구성 요소를 식별할 수 있습니다. 소비된 메시지 비율의 변화를 살펴봄으로써 뒤처지고 있는 시스템 부분을 찾는 데 크게 도움이 됩니다. 이러한 관찰 수준은 탄력성 결정을 내리고 현재 요구 사항을 충족하도록 시스템을 지속적으로 조정하는 데 필수적입니다.